<!DOCTYPE html>
<html>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js"></script>
	<head>
		<style>
			h1{
				text-align: center;
				font: italic;
				color: white;
			}
			p{
				text-align: center;
				color: white;
			}
			body{
				background-color: #232323;
			}
            .ACM2017WF{ text-align: center;
                margin-right: 150px;
                margin-left: 150px;
                color: white;
                
            }
		</style>

	</head>
	<body>
		<h1>MezMeRriZze's Blog</h1>
		<p>Competitive Programming\n\nMachine Learning\n\nComputer Graphics\n\nCuisine</p>
        <div class="ACM2017WF" data-ng-controllet="AppCtrl" id="myWebsite">
            <div class="problemC">
                <h4> ACM ICPC World Final 2017 Problem C </h4>
                We identify that this problem is simply a max bipartite matching problem. Since a row index and a column index defines a position, a high pile of crates can only contributes to at most one column and one row, i.e. no more than two. So we need to match the rows and columns that have same highest pile together via MaxFlow algorithm. But notice that if without the third camera, the bipartite graph is complete, so we do not need to use max flow, but since we have a third camera, the bipartite graph is incomplete, thus the greedy algorithm will not work. So we model the graph in a way that row i and column j have an edge iff the third camera indicates that there was originally a crate before we steal anything. Dinic results in O(V^2E).<br><br>
            </div>
            <div class="problemD">
                <h4> ACM ICPC World Final 2017 Problem D </h4>
                This question is an interesting binary search question. First we can eliminate all unnecessary consumers and producers if there exist a producer that has both first and second element smaller than the current one (higher for consumer). Then we have a plot looks some sort like a decision boundary of a SVM. And we can do binary search on consumers or producers whichever you prefer. WLOG we do it on producers, let mid be the middle one of the producers, then we can find the best match consumer bm to that particular producer. Then we can easily prove that all the producers to the left of this producer will have optimal match to the left part of bm, inclusive. Similarly for the right part of producers. Please note that if we cannot find any consumer to match for the producer we are caring about now, we need to go over all the consumers again to find the last one that has a positive price value difference to the mid, because when we move the the left part of the producers, we can only have a higher price, so that will complete the search for the left part. For the right part, since we cannot find a match, it means that all consumers are either to the left or below the mid producer, so we need to eliminate those to the left of it at least. And we don't really care for multiple best matches, the proof is easy (i.e. why the left and right subproblem still works).
            </div>
            <div class="problemE">
                <h4> ACM ICPC World Final 2017 Problem E </h4>
                This question is about solving a Single Variable Polynomial. Even though we cannot find a close form solution because that the order is uncertain, we can easily use the fact that this function is monotone despite some invalid points. So we can utilize binary search. And the invalid points can be avoided by translate the data so that the lowest speed is exactly zero. After that, the binary search is simply on the range [0,infinity], since we need 0 + positive to make the car move.<br><br>
            </div>
            <div class="problemF">
                <h4> ACM ICPC World Final 2017 Problem F </h4>
                There's not much choice about this problem, we can just brute force the solution since the time limit is super descent. We can model this brute force as Dynamic Programming to reduce the complexity.<br>
                E(num, lastv) = min v' < lastv<br>
                                E(num - 1, v') + delta(v', lastv)<br>
                num is the number of different R values we have utilized now, and lastv is the largest of those. Delta is the change of entropy when changing the largest v from v' to lastv, because the entropy stays unaffected by any lower v.
                We also need to memoize delta to speed up, this results in O(n^3).<br><br>
            </div>
            <div class="Leetcode 471 Encode String">
                <h4> Leetcode 471 Encode String </h4>
                This problem is a straight forward DP problem, or we can use brute force with memoization to reduce the overhead of figuring out the order of DP. The DP function would be: <br>
                    short(i,j) = min(kmp(i,j), minlen i <= k <= j <br>
                                short(i, k) + short(k, j))
                                    <br>
                    the kmp(i,j) is the subfunction of using kmp algorithm to find max recurrence in linear time. The total runtime would be O(N^3).

            </div>

            <md-button class="button" ng-click="showAlert($event)" > click </md-button>
        </div>
	</body>
</html>
